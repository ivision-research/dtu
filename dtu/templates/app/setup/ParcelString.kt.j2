package {{ app_pkg }}

// Automatically generated. Changes may be overwritten!

import android.content.ContentValues
import android.content.Intent
import android.os.*
import java.io.File
import kotlin.reflect.KClass

/**
 * ParcelString allows describing the contents of a Parcel as a String.
 *
 * As an example:
 *
 *  BIND,_INT10,_STRhello,BOOLtrue,RDFD/data/local/tmp/suchfile
 *
 * States that the parcel should contain a Binder (the default binder provided
 * by this application), the integer 10, and a the string "hello". This would
 * be written to the parcel as:
 *
 *  pcl.writeStrongBinder(LoggingBinder())
 *  pcl.writeInt(10)
 *  pcl.writeString("hello")
 *  pcl.writeInt(1)
 *  // Open /data/local/tmp/suchfile for reading and convert it to a
 *  // ParcelFileDescriptor
 *  pfd.writeToParcel(pcl)
 *
 *
 * The different allowed prefixes can all be found in [ParcelStringPrefix]
 *
 * Some notes:
 *  _STR understands some normal escape sequences, and there are some custom
 *    escapes required: '\,', '\:', '\|', '\>', and '\=' since these have special
 *    meanings to some value parsers.
 *
 *  _CMB creates a "combinaton" value. individual values inside are separted
 *   by '|', essentially glueing some values together. For example:
 *      _CMB_INT10|_INT12
 *   Translates into what is essentially a `Pair<Int, Int>`
 *
 *   _LST items are split with a ':': _LST_CMB_INT1|_INT2:_INT3|_INT4
 *
 *   _MAP items are split with a ':' and key value pairs are separated with
 *    an '='
 */
class ParcelString(private val values: List<Value>) {

    companion object {
        /**
         * Parse a String into a ParcelString
         *
         * @throws IllegalArgumentException
         */
        fun parse(s: String): ParcelString {
            alogv("ParcelString.parse($s)")
            return ParcelString(
                SimpleEscapeSplitter(',').split(s).map {
                    Value.fromString(it)
                }.toList()
            )
        }
    }

    fun writeToParcel(dest: Parcel, flags: Int) {
        for (v in values) {
            v.writeToParcel(dest, flags)
        }
    }
}

/**
 * Similar to a [ParcelString], but everything is a key value pair. For example:
 *
 * foo=_STRstr\=ing,bar=_INT10
 *
 * Would be equivalent to:
 *
 * putExtra("foo", "str=ing")
 * putExtra("bar", 10)
 */
class IntentString(private val values: Map<String, Value>) {

    companion object {
        /**
         * Parse a String into a ParcelString
         *
         * @throws IllegalArgumentException
         */
        fun parse(s: String): IntentString {
            alogv("IntentString.parse($s)")
            return IntentString(
                SimpleEscapeSplitter(',').split(s).map { kv ->
                    val kvList = SimpleEscapeSplitter('>').split(kv).toList()
                    if (kvList.size != 2) {
                        throw IllegalArgumentException(kv)
                    }
                    val key = Value.unescapeString(kvList[0])
                    val value = Value.fromString(kvList[1])
                    key to value
                }.toMap()
            )
        }
    }

    fun addToIntent(dest: Intent) {
        for (v in values.entries) {
            v.value.addToIntent(v.key, dest)
        }
    }

    fun asContentValues(): ContentValues {
        val cv = ContentValues()
        for (v in values.entries) {
            v.value.addToContentValues(v.key, cv)
        }
        return cv
    }

}

sealed class Value() {

    abstract fun writeToParcel(dest: Parcel, flags: Int)
    abstract fun addToIntent(key: String, intent: Intent)
    abstract fun addToContentValues(key: String, into: ContentValues)

    class VBinder(val value: IBinder) : Value() {

        override fun addToIntent(key: String, intent: Intent) {
            throw UnsupportedIntentUsage("IBinder")
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            throw UnsupportedContentValuesUsage("IBinder")
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeStrongBinder(value)
        }

        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VBinder {
                return VBinder(LoggingBinder())
            }
        }

    }

    class VShort(val value: Short) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VShort {
                return VShort(java.lang.Short.parseShort(s))
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            into.put(key, value)
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeInt(value.toInt())
        }

    }

    class VString(val value: String) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VString {
                return VString(unescapeString(s))
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            into.put(key, value)
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeString(value)
        }
    }

    class VFloat(val value: Float) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VFloat {
                return VFloat(java.lang.Float.parseFloat(s))
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            into.put(key, value)
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeFloat(value)
        }
    }

    class VDouble(val value: Double) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VDouble {
                return VDouble(java.lang.Double.parseDouble(s))
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            into.put(key, value)
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeDouble(value)
        }
    }

    class VLong(val value: Long) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VLong {
                return VLong(java.lang.Long.parseLong(s))
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            into.put(key, value)
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeLong(value)
        }
    }

    class VReadFd(val value: ParcelFileDescriptor) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VReadFd {
                return VReadFd(
                    ParcelFileDescriptor.open(
                        File(unescapeString(s)), ParcelFileDescriptor.MODE_READ_ONLY
                    )
                )
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            throw UnsupportedContentValuesUsage("ReadFd")
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            value.writeToParcel(dest, flags)
        }

    }

    class VWriteFd(val value: ParcelFileDescriptor) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VWriteFd {
                return VWriteFd(
                    ParcelFileDescriptor.open(
                        File(unescapeString(s)), ParcelFileDescriptor.MODE_READ_WRITE
                    )
                )
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            throw UnsupportedContentValuesUsage("WriteFd")
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            value.writeToParcel(dest, flags)
        }

    }

    class VNull() : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VNull {
                return VNull()
            }
        }

        override fun addToIntent(key: String, intent: Intent) {
            throw UnsupportedIntentUsage("untyped null")
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            throw UnsupportedContentValuesUsage("untyped null")
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeString(null)
        }
    }

    class VBundle(val value: Bundle) : Value() {
        companion object {
            @JvmStatic
            fun fromString(s: String): VBundle {
                val bundle = Bundle()
                SimpleEscapeSplitter(':').split(s).forEach { kv ->
                    val kvList = SimpleEscapeSplitter('=').split(kv).toList()
                    if (kvList.size != 2) {
                        throw IllegalArgumentException(kv)
                    }
                    val keyString = unescapeString(kvList[0])
                    val value = Value.fromString(kvList[1])
                    when (value) {
                        is VString -> {
                            bundle.putString(keyString, value.value)
                        }
                        is VBinder -> {
                            bundle.putBinder(keyString, value.value)
                        }
                        is VBool -> {
                            bundle.putBoolean(keyString, value.value)
                        }
                        is VBundle -> {
                            bundle.putBundle(keyString, value.value)
                        }
                        is VDouble -> {
                            bundle.putDouble(keyString, value.value)
                        }
                        is VFloat -> {
                            bundle.putFloat(keyString, value.value)
                        }
                        is VByte -> {
                            bundle.putByte(keyString, value.value)
                        }
                        is VInt -> {
                            bundle.putInt(keyString, value.value)
                        }
                        is VLong -> {
                            bundle.putLong(keyString, value.value)
                        }
                        is VShort -> {
                            bundle.putShort(keyString, value.value)
                        }
                        is VByteArray -> {
                            bundle.putByteArray(keyString, value.value)
                        }
                        // TODO This is partially doable
                        is VMap,
                            // TODO This is partially doable
                        is VList,
                        is VNull,
                        is VReadFd,
                        is VWriteFd,
                        is VCombined -> {
                            throw IllegalArgumentException("Bundle can't handle ${value.javaClass}: ${kvList[1]}")
                        }
                    }
                }
                return VBundle(bundle)
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            throw UnsupportedContentValuesUsage("Bundle")
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            value.writeToParcel(dest, flags)
        }
    }

    class VMap(val value: Map<Value, Value>) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VMap {
                val map = SimpleEscapeSplitter(':').split(s).map { kv ->
                    val kvList = SimpleEscapeSplitter('=').split(kv).toList()
                    if (kvList.size != 2) {
                        throw IllegalArgumentException(kv)
                    }
                    val key = Value.fromString(kvList[0])
                    val value = Value.fromString(kvList[1])
                    key to value
                }.toMap()
                return VMap(map)
            }
        }

        override fun addToIntent(key: String, intent: Intent) {
            throw UnsupportedIntentUsage("Map<Value, Value>")
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            throw UnsupportedContentValuesUsage("Map<Value, Value>")
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            val entries = value.entries
            dest.writeInt(entries.size)
            for (e in entries) {
                e.key.writeToParcel(dest, flags)
                e.value.writeToParcel(dest, flags)
            }
        }
    }

    class VList(val values: List<Value>) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VList {
                return VList(SimpleEscapeSplitter(':').split(s).map {
                    Value.fromString(it)
                }.toList())
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            throw UnsupportedContentValuesUsage("List<Value>")
        }

        override fun addToIntent(key: String, intent: Intent) {
            val allStrings = values.all {
                it is VString
            }
            val allInts = !allStrings && values.all {
                it is VInt
            }

            if (allStrings) {
                val arr = Array(values.size) { i ->
                    (values[i] as VString).value
                }
                intent.putExtra(key, arr)
            } else if (allInts) {
                val arr = Array(values.size) { i ->
                    (values[i] as VInt).value
                }
                intent.putExtra(key, arr)
            } else {
                throw UnsupportedIntentUsage("List<Value>")
            }

        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeInt(values.size)
            for (v in values) {
                v.writeToParcel(dest, flags)
            }
        }
    }


    class VCombined(val values: List<Value>) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VCombined {
                return VCombined(SimpleEscapeSplitter('|').split(s).map {
                    Value.fromString(it)
                }.toList())
            }
        }

        override fun addToIntent(key: String, intent: Intent) {
            throw UnsupportedIntentUsage("List<Value>")
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            throw UnsupportedContentValuesUsage("List<Value>")
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            for (v in values) {
                v.writeToParcel(dest, flags)
            }
        }
    }

    class VByte(val value: Byte) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VByte {
                return VByte(byteFromHexNibbles(s[0], s[1]))
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            into.put(key, value)
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeByte(value)
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }
    }


    class VInt(val value: Int) : Value() {
        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VInt {
                return VInt(Integer.parseInt(s))
            }
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeInt(value)
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            into.put(key, value)
        }
    }

    class VByteArray(val value: ByteArray) : Value() {

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            dest.writeByteArray(value)
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            into.put(key, value)
        }

        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VByteArray {
                return if (s.startsWith("0x")) {
                    VByteArray(s.substring(2).hexToBytes())
                } else {
                    VByteArray(s.hexToBytes())
                }
            }
        }
    }

    class VBool(val value: Boolean) : Value() {
        override fun writeToParcel(dest: Parcel, flags: Int) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                dest.writeBoolean(value)
            } else {
                dest.writeInt(
                    if (value) {
                        1
                    } else {
                        0
                    }
                )
            }
        }

        override fun addToContentValues(key: String, into: ContentValues) {
            into.put(key, value)
        }

        override fun addToIntent(key: String, intent: Intent) {
            intent.putExtra(key, value)
        }

        companion object {
            @UsedViaReflection
            @JvmStatic
            fun fromString(s: String): VBool {
                return VBool(s.lowercase() == "true")
            }
        }
    }

    companion object {

        @JvmStatic
        fun fromString(s: String): Value {
            alogv("Value.fromString($s)")
            val prefix = s.substring(0, 4)
            val remaining = s.substring(4)
            for (e in ParcelStringPrefix.values()) {
                if (e.prefix == prefix) {
                    val method =
                        e.clazz?.java?.getDeclaredMethod("fromString", String::class.java)
                            ?: throw RuntimeException("class ${e.clazz} needs a companion with the fromString method")
                    return method.invoke(null, remaining) as Value
                }
            }
            throw IllegalArgumentException("invalid parcel string: $s")
        }

        fun unescapeString(s: String): String {
            val unescaped = StringBuilder()
            var escaped = false
            val chars = s.toCharArray()
            val size = chars.size
            var idx = 0
            while (idx < size) {
                if (escaped) {
                    idx += handleEscaped(idx, chars, unescaped)
                    escaped = false
                    continue
                }

                val c = chars[idx]
                idx += 1
                when (c) {
                    '\\' -> escaped = true
                    else -> unescaped.append(c)
                }
            }
            return unescaped.toString()
        }

        fun handleEscaped(idx: Int, chars: CharArray, into: StringBuilder): Int {
            val c = chars[idx]
            return when (c) {
                '\\' -> {
                    into.append('\\'); 1
                }
                'n' -> {
                    into.append('\n'); 1
                }
                't' -> {
                    into.append('\t'); 1
                }
                'b' -> {
                    into.append('\b'); 1
                }
                'r' -> {
                    into.append('\r'); 1
                }
                'x' -> {
                    val high = chars[idx + 1]
                    val low = chars[idx + 2]
                    val b = byteFromHexNibbles(high, low)
                    into.append(b.toAsciiChar())
                    3
                }
                'u' -> {
                    val high = byteFromHexNibbles(chars[idx + 1], chars[idx + 2]).toInt().shl(8)
                    val low = byteFromHexNibbles(chars[idx + 3], chars[idx + 4]).toInt()
                    into.append(high.or(low).toChar())
                    5
                }
                // Just convenient since some things might escape these
                '\"', '\'' -> {
                    into.append(c); 1
                }
                // Custom escapes
                '=', ':', '|', ',', '>' -> {
                    into.append(c); 1
                }
                else -> throw IllegalArgumentException("unexpected escape $c")
            }
        }
    }
}

enum class ParcelStringPrefix(val prefix: String, val clazz: KClass<out Value>) {
    VBinder("BIND", Value.VBinder::class),
    VByte("BYTE", Value.VByte::class),
    VBool("BOOL", Value.VBool::class),
    VInt("_INT", Value.VInt::class),
    VShort("SHRT", Value.VShort::class),
    VString("_STR", Value.VString::class),
    VFloat("_FLT", Value.VFloat::class),
    VDouble("DUBL", Value.VDouble::class),
    VLong("LONG", Value.VLong::class),
    VReadFd("RDFD", Value.VReadFd::class),
    VWriteFd("WRFD", Value.VWriteFd::class),
    VNull("NULL", Value.VNull::class),
    VBundle("BUND", Value.VBundle::class),
    VMap("_MAP", Value.VMap::class),
    VList("LIST", Value.VList::class),
    VByteArray("BARR", Value.VByteArray::class),
    VCombined("_CMB", Value.VCombined::class),
}

/**
 * Splits a string on a value that may be escaped.
 *
 * For example:
 *
 *  SimpleEscapeSplitter(',').split("foo,bar\\n\\,baz,bar")
 *
 * Would create a sequence returning:
 *  - "foo"
 *  - "bar\\n,baz"
 *  - "bar"
 */
class SimpleEscapeSplitter(private val splitChar: Char) {
    fun split(s: String): Sequence<String> {

        val chars = s.toCharArray()
        val count = chars.size
        var idx = 0
        val part = StringBuilder()
        var escaped = false
        return generateSequence {
            if (idx >= count) {
                return@generateSequence null
            }
            while (idx < count) {
                val c = chars[idx]
                idx += 1
                if (escaped) {
                    // Restore the escape
                    if (c != splitChar) {
                        part.append('\\')
                    }
                    part.append(c)
                    escaped = false
                } else if (c == '\\') {
                    escaped = true
                } else if (c == splitChar) {
                    val string = part.toString()
                    part.clear()
                    return@generateSequence string
                } else {
                    part.append(c)
                }
            }
            val string = part.toString()
            part.clear()
            return@generateSequence string

        }

    }
}

class UnsupportedIntentUsage(type: String) : Exception("$type can't be written to an intent")
class UnsupportedContentValuesUsage(type: String) :
    Exception("$type can't be written to ContentValues")
